<!DOCTYPE html>
<html lang="zh-CN" class="scroll-smooth">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QPSK算法 - 数字通信技术</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.1/css/all.min.css">
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f0f9ff',
                            100: '#e0f2fe',
                            200: '#bae6fd',
                            300: '#7dd3fc',
                            400: '#38bdf8',
                            500: '#0ea5e9',
                            600: '#0284c7',
                            700: '#0369a1',
                            800: '#075985',
                            900: '#0c4a6e',
                        }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.5s ease-in-out',
                        'slide-in': 'slideIn 0.5s ease-in-out',
                        'pulse-slow': 'pulse 3s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                    },
                    keyframes: {
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' },
                        },
                        slideIn: {
                            '0%': { transform: 'translateY(20px)', opacity: '0' },
                            '100%': { transform: 'translateY(0)', opacity: '1' },
                        }
                    },
                }
            }
        }
    </script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@300;400;500;700&display=swap');
        
        body {
            font-family: 'Noto Sans SC', sans-serif;
        }
        
        .concept-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
        }
        
        .code-block {
            background-color: #f8f9fa;
        }

        .dark .code-block {
            background-color: #1e293b;
        }
        
        .animate-on-scroll {
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s ease, transform 0.5s ease;
        }
        
        .animate-on-scroll.visible {
            opacity: 1;
            transform: translateY(0);
        }

        .qpsk-constellation-point {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .qpsk-constellation-point:hover {
            r: 8;
        }
    </style>
</head>
<body class="bg-gray-50 text-gray-800 dark:bg-gray-900 dark:text-gray-200 transition-colors duration-300">
    <!-- 顶部导航栏 -->
    <header class="sticky top-0 z-50 bg-white dark:bg-gray-800 shadow-md">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <div class="flex items-center space-x-2">
                <i class="fas fa-signal text-primary-600 dark:text-primary-400 text-2xl"></i>
                <h1 class="text-xl font-bold">QPSK算法</h1>
            </div>
            <div class="flex items-center space-x-4">
                <button id="theme-toggle" class="p-2 rounded-full hover:bg-gray-200 dark:hover:bg-gray-700">
                    <i class="fas fa-moon hidden dark:block text-yellow-300"></i>
                    <i class="fas fa-sun block dark:hidden text-yellow-500"></i>
                </button>
                <a href="#simulation" class="px-4 py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-md shadow transition duration-300 hidden md:block">
                    <i class="fas fa-play mr-2"></i>仿真演示
                </a>
            </div>
        </div>
    </header>

    <!-- 主内容区 -->
    <main class="container mx-auto px-4 py-8">
        <!-- 课程介绍 -->
        <section class="mb-12 animate-on-scroll">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 md:p-8 transition-all duration-300">
                <h2 class="text-2xl font-bold mb-4 text-primary-700 dark:text-primary-400 flex items-center">
                    <i class="fas fa-book-open mr-2"></i>QPSK调制技术概述
                </h2>
                <p class="mb-4 leading-relaxed">
                    正交相移键控（Quadrature Phase Shift Keying，QPSK）是数字通信中的一种高效调制技术，它通过改变载波信号的相位来传输数字信息。QPSK在每个符号周期内可以传输2比特信息，相比于传统的二进制相移键控（BPSK）提高了频带利用率。
                </p>
                <p class="leading-relaxed">
                    QPSK被广泛应用于卫星通信、移动通信、无线局域网等多个领域，是现代通信系统中不可或缺的关键技术。本课程将深入探讨QPSK的原理、实现方法以及性能分析。
                </p>
            </div>
        </section>

        <!-- 核心知识点 -->
        <section class="mb-12 animate-on-scroll">
            <h2 class="text-2xl font-bold mb-6 text-center text-gray-800 dark:text-gray-200">QPSK的核心原理是什么？</h2>
            
            <div class="grid md:grid-cols-2 gap-6">
                <!-- 左侧：理论讲解 -->
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300">
                    <h3 class="text-xl font-semibold mb-4 text-primary-600 dark:text-primary-400">QPSK调制原理</h3>
                    
                    <p class="mb-4">QPSK调制通过载波的四个不同相位来表示四种不同的符号状态，每个符号可以承载2比特信息。QPSK的数学表达式为：</p>
                    
                    <div id="qpsk-formula" class="my-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg overflow-x-auto">
                        s_i(t) = \sqrt{\frac{2E_s}{T_s}}\cos\left(2\pi f_c t + (2i-1)\frac{\pi}{4}\right), \ i=1,2,3,4
                    </div>
                    
                    <p class="mb-4">其中：</p>
                    <ul class="list-disc list-inside space-y-2 mb-4">
                        <li><span class="font-medium">E_s</span> - 每个符号的能量</li>
                        <li><span class="font-medium">T_s</span> - 符号周期</li>
                        <li><span class="font-medium">f_c</span> - 载波频率</li>
                        <li><span class="font-medium">(2i-1)\frac{\pi}{4}</span> - 相位偏移</li>
                    </ul>
                    
                    <p class="mt-4">QPSK调制可以通过同相分支（I分支）和正交分支（Q分支）来实现：</p>
                    
                    <div id="iq-formula" class="my-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg overflow-x-auto">
                        \begin{align}
                        s(t) &= I(t)\cos(2\pi f_c t) - Q(t)\sin(2\pi f_c t) \\
                        &= \sqrt{\frac{E_s}{T_s}}[d_I(t)\cos(2\pi f_c t) - d_Q(t)\sin(2\pi f_c t)]
                        \end{align}
                    </div>
                    
                    <p>其中，d_I(t)和d_Q(t)分别是同相和正交数据流，通常取值为±1。</p>
                </div>

                <!-- 右侧：星座图可视化 -->
                <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300 flex flex-col">
                    <h3 class="text-xl font-semibold mb-4 text-primary-600 dark:text-primary-400">QPSK星座图</h3>
                    
                    <p class="mb-4">QPSK调制使用的是四个相等幅度、相位差为90°的信号点，在星座图上呈正方形分布：</p>
                    
                    <div class="flex-1 flex items-center justify-center">
                        <div class="w-full h-64 md:h-80 relative">
                            <svg id="qpsk-constellation" class="w-full h-full"></svg>
                        </div>
                    </div>
                    
                    <div class="mt-4">
                        <p class="text-sm text-gray-600 dark:text-gray-400">
                            在QPSK调制中，每个符号点代表2比特信息。点击星座图上的点查看对应的二进制值和相位信息。
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- QPSK系统框图 -->
        <section class="mb-12 animate-on-scroll">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300">
                <h2 class="text-2xl font-bold mb-4 text-primary-700 dark:text-primary-400 flex items-center">
                    <i class="fas fa-project-diagram mr-2"></i>QPSK系统框图
                </h2>
                
                <div class="grid md:grid-cols-2 gap-8 mt-6">
                    <!-- 发射端 -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-primary-600 dark:text-primary-400">QPSK发射端</h3>
                        <div class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4">
                            <div id="qpsk-transmitter-diagram" class="w-full h-64"></div>
                        </div>
                        <p class="mt-3 text-sm">
                            QPSK发射端首先将输入的串行比特流转换为并行的I路和Q路数据，然后分别进行载波调制。通过正交载波合成得到最终的QPSK信号。
                        </p>
                    </div>
                    
                    <!-- 接收端 -->
                    <div>
                        <h3 class="text-lg font-semibold mb-3 text-primary-600 dark:text-primary-400">QPSK接收端</h3>
                        <div class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4">
                            <div id="qpsk-receiver-diagram" class="w-full h-64"></div>
                        </div>
                        <p class="mt-3 text-sm">
                            QPSK接收端通过相干解调分别恢复I路和Q路数据，然后结合判决门限进行数据判决，最后将并行数据转换回串行比特流。
                        </p>
                    </div>
                </div>
            </div>
        </section>

        <!-- QPSK调制与解调的数学原理 -->
        <section class="mb-12 animate-on-scroll">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300">
                <h2 class="text-2xl font-bold mb-6 text-primary-700 dark:text-primary-400">QPSK的数学原理剖析</h2>
                
                <div class="grid md:grid-cols-2 gap-8">
                    <!-- 调制过程 -->
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-primary-600 dark:text-primary-400">调制过程</h3>
                        <p class="mb-4">QPSK调制的关键是将两个比特映射到一个符号，并利用载波的相位进行调制：</p>
                        
                        <ol class="list-decimal list-inside space-y-3 mb-4">
                            <li>将输入比特流每两个分为一组: (b<sub>k</sub>, b<sub>k+1</sub>)</li>
                            <li>将它们映射到I路和Q路上: I = 2b<sub>k</sub>-1, Q = 2b<sub>k+1</sub>-1</li>
                            <li>生成调制信号:
                                <div id="modulation-formula" class="my-2 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg overflow-x-auto">
                                s(t) = I \cdot \cos(2\pi f_c t) - Q \cdot \sin(2\pi f_c t)
                                </div>
                            </li>
                        </ol>
                        
                        <div class="mt-4 p-4 bg-blue-50 dark:bg-blue-900/20 rounded-lg">
                            <h4 class="font-medium mb-2 text-blue-700 dark:text-blue-300">符号映射表</h4>
                            <table class="w-full border-collapse">
                                <thead>
                                    <tr class="bg-blue-100 dark:bg-blue-800/30">
                                        <th class="border border-blue-200 dark:border-blue-700 px-3 py-2">二进制对</th>
                                        <th class="border border-blue-200 dark:border-blue-700 px-3 py-2">I</th>
                                        <th class="border border-blue-200 dark:border-blue-700 px-3 py-2">Q</th>
                                        <th class="border border-blue-200 dark:border-blue-700 px-3 py-2">相位</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">00</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">-1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">-1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">225°</td>
                                    </tr>
                                    <tr>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">01</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">-1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">135°</td>
                                    </tr>
                                    <tr>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">10</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">-1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">315°</td>
                                    </tr>
                                    <tr>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">11</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">1</td>
                                        <td class="border border-blue-200 dark:border-blue-700 px-3 py-2 text-center">45°</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    
                    <!-- 解调过程 -->
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-primary-600 dark:text-primary-400">解调过程</h3>
                        <p class="mb-4">QPSK解调采用相干解调技术，利用本地载波与接收信号相乘并积分来恢复原始数据：</p>
                        
                        <ol class="list-decimal list-inside space-y-3 mb-4">
                            <li>接收到的信号 r(t) = s(t) + n(t)，其中n(t)是噪声</li>
                            <li>I路解调:
                                <div id="i-demodulation-formula" class="my-2 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg overflow-x-auto">
                                I' = \frac{2}{T_s}\int_0^{T_s} r(t) \cdot \cos(2\pi f_c t) dt
                                </div>
                            </li>
                            <li>Q路解调:
                                <div id="q-demodulation-formula" class="my-2 p-3 bg-gray-50 dark:bg-gray-700 rounded-lg overflow-x-auto">
                                Q' = -\frac{2}{T_s}\int_0^{T_s} r(t) \cdot \sin(2\pi f_c t) dt
                                </div>
                            </li>
                            <li>判决:
                                <ul class="list-disc list-inside ml-4 mt-2">
                                    <li>如果 I' > 0，则 b<sub>k</sub> = 1，否则 b<sub>k</sub> = 0</li>
                                    <li>如果 Q' > 0，则 b<sub>k+1</sub> = 1，否则 b<sub>k+1</sub> = 0</li>
                                </ul>
                            </li>
                        </ol>
                        
                        <div class="mt-4 p-4 bg-green-50 dark:bg-green-900/20 rounded-lg">
                            <h4 class="font-medium mb-2 text-green-700 dark:text-green-300">QPSK性能特点</h4>
                            <ul class="list-disc list-inside space-y-2">
                                <li>比特误码率表达式：
                                    <div id="ber-formula" class="my-2 p-2 bg-gray-50 dark:bg-gray-700 rounded-lg overflow-x-auto">
                                    P_b = Q\left(\sqrt{\frac{2E_b}{N_0}}\right)
                                    </div>
                                </li>
                                <li>与BPSK相比，在相同误码率条件下，QPSK的频带效率提高了一倍</li>
                                <li>抗噪性能与BPSK相同，但带宽效率更高</li>
                                <li>在高噪声环境下依然保持良好性能</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- QPSK仿真演示 -->
        <section id="simulation" class="mb-12 animate-on-scroll scroll-mt-20">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300">
                <h2 class="text-2xl font-bold mb-6 text-primary-700 dark:text-primary-400 flex items-center">
                    <i class="fas fa-laptop-code mr-2"></i>QPSK交互式仿真演示
                </h2>
                
                <div class="grid lg:grid-cols-3 gap-6">
                    <!-- 仿真控制 -->
                    <div class="lg:col-span-1">
                        <div class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4">
                            <h3 class="font-semibold mb-4 text-center text-primary-600 dark:text-primary-400">仿真参数设置</h3>
                            
                            <div class="space-y-4">
                                <div>
                                    <label class="block mb-2 text-sm font-medium">输入比特序列</label>
                                    <input id="bit-sequence" type="text" value="1010110001" class="w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm">
                                </div>
                                
                                <div>
                                    <label class="block mb-2 text-sm font-medium">采样率 (每符号采样点数)</label>
                                    <input id="samples-per-symbol" type="range" min="8" max="32" value="16" class="w-full">
                                    <div class="flex justify-between text-xs mt-1">
                                        <span>8</span>
                                        <span>16</span>
                                        <span>24</span>
                                        <span>32</span>
                                    </div>
                                </div>
                                
                                <div>
                                    <label class="block mb-2 text-sm font-medium">信噪比 (dB)</label>
                                    <input id="snr-value" type="range" min="0" max="20" value="10" class="w-full">
                                    <div class="flex justify-between text-xs mt-1">
                                        <span>0</span>
                                        <span>5</span>
                                        <span>10</span>
                                        <span>15</span>
                                        <span>20</span>
                                    </div>
                                </div>
                                
                                <button id="start-simulation" class="w-full py-2 bg-primary-500 hover:bg-primary-600 text-white rounded-md shadow transition duration-300">
                                    <i class="fas fa-play mr-2"></i>开始仿真
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 仿真结果显示 -->
                    <div class="lg:col-span-2 flex flex-col">
                        <div class="tabs flex space-x-1 mb-4">
                            <button class="simulation-tab active px-4 py-2 rounded-t-lg bg-gray-200 dark:bg-gray-700" data-target="waveform-tab">波形图</button>
                            <button class="simulation-tab px-4 py-2 rounded-t-lg bg-gray-100 dark:bg-gray-800" data-target="constellation-tab">星座图</button>
                            <button class="simulation-tab px-4 py-2 rounded-t-lg bg-gray-100 dark:bg-gray-800" data-target="eye-diagram-tab">眼图</button>
                        </div>
                        
                        <div class="flex-1 bg-gray-100 dark:bg-gray-700 rounded-lg p-4">
                            <!-- 波形图 -->
                            <div id="waveform-tab" class="tab-content">
                                <canvas id="qpsk-waveform" class="w-full h-[300px]"></canvas>
                                <div class="grid grid-cols-2 gap-4 mt-4">
                                    <div>
                                        <h4 class="text-sm font-medium mb-2">调制前的I/Q数据</h4>
                                        <canvas id="iq-data" class="w-full h-[100px]"></canvas>
                                    </div>
                                    <div>
                                        <h4 class="text-sm font-medium mb-2">调制后的信号</h4>
                                        <canvas id="modulated-signal" class="w-full h-[100px]"></canvas>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- 星座图 -->
                            <div id="constellation-tab" class="tab-content hidden">
                                <canvas id="qpsk-constellation-plot" class="w-full h-[400px]"></canvas>
                                <div class="mt-4 text-sm">
                                    <p><strong>传输误码率:</strong> <span id="ber-value">0.0%</span></p>
                                    <p class="mt-2">星座图显示了接收符号在I-Q平面上的分布，噪声会导致符号点偏离其理想位置。</p>
                                </div>
                            </div>
                            
                            <!-- 眼图 -->
                            <div id="eye-diagram-tab" class="tab-content hidden">
                                <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                                    <div>
                                        <h4 class="text-sm font-medium mb-2">I路眼图</h4>
                                        <canvas id="eye-diagram-i" class="w-full h-[180px]"></canvas>
                                    </div>
                                    <div>
                                        <h4 class="text-sm font-medium mb-2">Q路眼图</h4>
                                        <canvas id="eye-diagram-q" class="w-full h-[180px]"></canvas>
                                    </div>
                                </div>
                                <div class="mt-4 text-sm">
                                    <p>眼图反映了信号失真程度和系统时序误差。眼越"开"，系统性能越好。</p>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- MATLAB实现代码 -->
        <section class="mb-12 animate-on-scroll">
            <div class="bg-white dark:bg-gray-800 rounded-xl shadow-lg p-6 transition-all duration-300">
                <h2 class="text-2xl font-bold mb-6 text-primary-700 dark:text-primary-400 flex items-center">
                    <i class="fas fa-code mr-2"></i>QPSK的MATLAB实现
                </h2>
                
                <div class="bg-gray-100 dark:bg-gray-700 rounded-lg p-4 mb-6">
                    <h3 class="font-semibold mb-2 text-primary-600 dark:text-primary-400">QPSK调制解调完整代码</h3>
                    <pre class="code-block text-sm p-4 rounded-lg overflow-x-auto">
% QPSK调制解调完整示例
clear all; close all;

% 参数设置
N = 10000;                 % 比特数
nsamp = 16;                % 每个符号的采样点数
Rb = 1000;                 % 比特率 (bps)
fc = 10000;                % 载波频率 (Hz)
SNRdB = 10;                % 信噪比 (dB)

% 生成随机比特流
bits = randi([0 1], 1, N);

% 将比特转换为符号
symbols = zeros(1, N/2);
for i = 1:N/2
    if bits(2*i-1)==0 && bits(2*i)==0
        symbols(i) = exp(1j*5*pi/4);    % 00 -> 225°
    elseif bits(2*i-1)==0 && bits(2*i)==1
        symbols(i) = exp(1j*3*pi/4);    % 01 -> 135°
    elseif bits(2*i-1)==1 && bits(2*i)==0
        symbols(i) = exp(1j*7*pi/4);    % 10 -> 315°
    else
        symbols(i) = exp(1j*pi/4);      % 11 -> 45°
    end
end

% 上采样
symbolsUp = upsample(symbols, nsamp);

% 脉冲成型滤波
span = 4;                           % 滤波器符号跨度
rolloff = 0.5;                      % 滚降因子
rrcFilter = rcosdesign(rolloff, span, nsamp, 'sqrt');
filteredSymbols = filter(rrcFilter, 1, symbolsUp);

% 计算I和Q分量
I = real(filteredSymbols);
Q = imag(filteredSymbols);

% 生成载波
t = (0:length(filteredSymbols)-1)/(nsamp*Rb/2);
carrier_I = cos(2*pi*fc*t);
carrier_Q = sin(2*pi*fc*t);

% QPSK调制
modulated = I.*carrier_I - Q.*carrier_Q;

% 添加噪声
SNR = 10^(SNRdB/10);
Ps = sum(abs(modulated).^2)/length(modulated); % 信号功率
N0 = Ps/SNR;                                  % 噪声功率
noise = sqrt(N0/2)*randn(size(modulated));    % 高斯白噪声
received = modulated + noise;

% 接收端解调
received_I = received .* carrier_I;
received_Q = -received .* carrier_Q;

% 低通滤波
[b, a] = butter(6, fc/(nsamp*Rb));
filtered_I = filter(b, a, received_I);
filtered_Q = filter(b, a, received_Q);

% 匹配滤波
matched_I = filter(rrcFilter, 1, filtered_I);
matched_Q = filter(rrcFilter, 1, filtered_Q);

% 下采样
sampled_I = matched_I(span*nsamp+1:nsamp:end);
sampled_Q = matched_Q(span*nsamp+1:nsamp:end);

% 判决
detected_symbols = sampled_I + 1j*sampled_Q;
detected_bits = zeros(1, N);

for i = 1:length(detected_symbols)
    phase = angle(detected_symbols(i));
    if phase >= -pi/4 && phase < pi/4
        detected_bits(2*i-1) = 1;
        detected_bits(2*i) = 1;
    elseif phase >= pi/4 && phase < 3*pi/4
        detected_bits(2*i-1) = 0;
        detected_bits(2*i) = 1;
    elseif (phase >= 3*pi/4 && phase <= pi) || (phase >= -pi && phase < -3*pi/4)
        detected_bits(2*i-1) = 0;
        detected_bits(2*i) = 0;
    else
        detected_bits(2*i-1) = 1;
        detected_bits(2*i) = 0;
    end
end

% 计算误码率
errors = sum(bits ~= detected_bits);
ber = errors / N;
fprintf('误码率 (BER): %f\n', ber);

% 绘制星座图
figure;
plot(sampled_I, sampled_Q, 'r.');
hold on;
plot(real(symbols), imag(symbols), 'bo');
title('QPSK星座图');
xlabel('同相分量 (I)');
ylabel('正交分量 (Q)');
legend('接收符号', '发送符号');
grid on;
axis equal;

% 绘制眼图
eyediagram(matched_I(nsamp*span:end), 2*nsamp);
title('I路眼图');
figure;
eyediagram(matched_Q(nsamp*span:end), 2*nsamp);
title('Q路眼图');
</pre>
                </div>
                
                <div class="grid md:grid-cols-2 gap-6">
                    <div>
                        <h3 class="font-semibold mb-2 text-primary-600 dark:text-primary-400">QPSK调制器核心函数</h3>
                        <pre class="code-block text-sm p-4 rounded-lg overflow-x-auto">
function modulated = qpsk_modulator(bits, sps, rolloff)
% QPSK调制器函数
% 输入:
%   bits - 输入比特序列
%   sps - 每个符号的样本数
%   rolloff - RRC滤波器的滚降因子
% 输出:
%   modulated - 复信号表示的QPSK已调信号

% 确保比特数为偶数
if mod(length(bits), 2) ~= 0
    bits = [bits 0];
end

% 将比特转换为符号
N = length(bits)/2;
symbols = zeros(1, N);
for i = 1:N
    if bits(2*i-1)==0 && bits(2*i)==0
        symbols(i) = -1-1j;    % 00
    elseif bits(2*i-1)==0 && bits(2*i)==1
        symbols(i) = -1+1j;    % 01
    elseif bits(2*i-1)==1 && bits(2*i)==0
        symbols(i) = 1-1j;     % 10
    else
        symbols(i) = 1+1j;     % 11
    end
end

% 上采样
symbols_up = upsample(symbols, sps);

% 应用RRC脉冲成型滤波器
span = 8;
rrc_filter = rcosdesign(rolloff, span, sps, 'sqrt');
modulated = filter(rrc_filter, 1, symbols_up);

end</pre>
                    </div>
                    
                    <div>
                        <h3 class="font-semibold mb-2 text-primary-600 dark:text-primary-400">QPSK解调器核心函数</h3>
                        <pre class="code-block text-sm p-4 rounded-lg overflow-x-auto">
function [detected_bits, ber] = qpsk_demodulator(received, original_bits, sps, rolloff)
% QPSK解调器函数
% 输入:
%   received - 接收到的QPSK信号
%   original_bits - 原始比特序列（用于计算BER）
%   sps - 每个符号的样本数
%   rolloff - RRC滤波器的滚降因子
% 输出:
%   detected_bits - 解调出的比特序列
%   ber - 误码率

% 匹配滤波
span = 8;
rrc_filter = rcosdesign(rolloff, span, sps, 'sqrt');
filtered = filter(rrc_filter, 1, received);

% 消除滤波器引入的延迟
delay = span*sps/2;
filtered = filtered(delay+1:end);

% 下采样到符号率
symbols = filtered(1:sps:end);

% 符号判决
detected_symbols = zeros(size(symbols));
for i = 1:length(symbols)
    if real(symbols(i)) >= 0 && imag(symbols(i)) >= 0
        detected_symbols(i) = 1+1j;      % 11
    elseif real(symbols(i)) < 0 && imag(symbols(i)) >= 0
        detected_symbols(i) = -1+1j;     % 01
    elseif real(symbols(i)) >= 0 && imag(symbols(i)) < 0
        detected_symbols(i) = 1-1j;      % 10
    else
        detected_symbols(i) = -1-1j;     % 00
    end
end

% 将符号转换回比特
N = length(detected_symbols);
detected_bits = zeros(1, 2*N);
for i = 1:N
    if detected_symbols(i) == -1-1j       % 00
        detected_bits(2*i-1:2*i) = [0 0];
    elseif detected_symbols(i) == -1+1j   % 01
        detected_bits(2*i-1:2*i) = [0 1];
    elseif detected_symbols(i) == 1-1j    % 10
        detected_bits(2*i-1:2*i) = [1 0];
    else                                  % 11
        detected_bits(2*i-1:2*i) = [1 1];
    end
end

% 截断多余的比特
detected_bits = detected_bits(1:length(original_bits));

% 计算BER
errors = sum(detected_bits ~= original_bits);
ber = errors / length(original_bits);

end</pre>
                    </div>
                </div>
            </div>
        </section>

        <!-- 思考题 -->
        <section class="mb-12 animate-on-scroll">
            <div class="bg-indigo-50 dark:bg-indigo-900/20 rounded-xl shadow-lg p-6 transition-all duration-300">
                <h2 class="text-2xl font-bold mb-4 text-indigo-700 dark:text-indigo-400 flex items-center">
                    <i class="fas fa-brain mr-2"></i>思考与延伸
                </h2>
                
                <div class="space-y-4">
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg">
                        <h3 class="font-semibold text-lg mb-2 text-indigo-600 dark:text-indigo-400">1. QPSK与其他调制技术的比较</h3>
                        <p>与BPSK相比，QPSK的带宽效率提高了一倍，但抗噪声能力是否也有所改变？如何比较QPSK与QAM-16在频谱效率和抗噪声性能方面的差异？</p>
                    </div>
                    
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg">
                        <h3 class="font-semibold text-lg mb-2 text-indigo-600 dark:text-indigo-400">2. 差分QPSK</h3>
                        <p>差分QPSK (DQPSK) 不需要相干解调，但会牺牲一定的性能。请思考DQPSK的工作原理以及它在什么场景下比传统QPSK更适用？</p>
                    </div>
                    
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg">
                        <h3 class="font-semibold text-lg mb-2 text-indigo-600 dark:text-indigo-400">3. 符号映射方案的影响</h3>
                        <p>格雷编码通常用于QPSK符号映射。请思考为什么格雷编码能够减小误码率？如果采用自然二进制编码，会产生什么影响？</p>
                    </div>
                    
                    <div class="p-4 bg-white dark:bg-gray-800 rounded-lg">
                        <h3 class="font-semibold text-lg mb-2 text-indigo-600 dark:text-indigo-400">4. 实际应用的挑战</h3>
                        <p>在实际通信系统中，QPSK面临相位噪声、频率偏移等问题。试分析这些因素如何影响QPSK的性能，以及工程上如何解决这些问题？</p>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- 页脚 -->
    <footer class="bg-white dark:bg-gray-800 shadow-md py-6">
        <div class="container mx-auto px-4">
            <div class="flex flex-col md:flex-row justify-between items-center">
                <div>
                    <p class="font-bold text-primary-600 dark:text-primary-400">IECUBE Tutorial</p>
                    <p class="text-sm text-gray-600 dark:text-gray-400">© 2025 版权所有</p>
                </div>
                
                <p class="text-xs text-gray-500 dark:text-gray-500 mt-4 md:mt-0 text-center md:text-right max-w-md">
                    本内容为人工智能生成，观点为转述原作者，不代表本公司立场，仅供参考和批判
                </p>
            </div>
        </div>
    </footer>

    <!-- 脚本 -->
    <script>
        // 深色模式切换
        const themeToggleBtn = document.getElementById('theme-toggle');
        
        function setTheme() {
            if (localStorage.theme === 'dark' || 
                (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
                document.documentElement.classList.add('dark');
            } else {
                document.documentElement.classList.remove('dark');
            }
        }
        
        setTheme();
        
        themeToggleBtn.addEventListener('click', () => {
            if (document.documentElement.classList.contains('dark')) {
                document.documentElement.classList.remove('dark');
                localStorage.theme = 'light';
            } else {
                document.documentElement.classList.add('dark');
                localStorage.theme = 'dark';
            }
        });
        
        // 滚动动画
        const animateOnScrollElements = document.querySelectorAll('.animate-on-scroll');
        
        function checkScroll() {
            animateOnScrollElements.forEach(element => {
                const elementTop = element.getBoundingClientRect().top;
                const windowHeight = window.innerHeight;
                
                if (elementTop < windowHeight * 0.9) {
                    element.classList.add('visible');
                }
            });
        }
        
        window.addEventListener('scroll', checkScroll);
        window.addEventListener('load', checkScroll);
        
        // 渲染数学公式
        document.addEventListener("DOMContentLoaded", function() {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false},
                    {left: "\\(", right: "\\)", display: false},
                    {left: "\\[", right: "\\]", display: true}
                ],
                throwOnError: false
            });
        });
        
        // 标签页切换
        const tabButtons = document.querySelectorAll('.simulation-tab');
        const tabContents = document.querySelectorAll('.tab-content');
        
        tabButtons.forEach(button => {
            button.addEventListener('click', () => {
                // 移除所有active类
                tabButtons.forEach(b => b.classList.remove('active', 'bg-gray-200', 'dark:bg-gray-700'));
                tabButtons.forEach(b => b.classList.add('bg-gray-100', 'dark:bg-gray-800'));
                
                // 给当前按钮添加active类
                button.classList.add('active', 'bg-gray-200', 'dark:bg-gray-700');
                button.classList.remove('bg-gray-100', 'dark:bg-gray-800');
                
                // 隐藏所有内容
                tabContents.forEach(content => content.classList.add('hidden'));
                
                // 显示目标内容
                const targetId = button.getAttribute('data-target');
                document.getElementById(targetId).classList.remove('hidden');
            });
        });
        
        // QPSK星座图绘制
        const svgNS = "http://www.w3.org/2000/svg";
        const constellationSvg = document.getElementById('qpsk-constellation');
        
        function drawQpskConstellation() {
            // 清除现有内容
            constellationSvg.innerHTML = '';
            
            const isDarkMode = document.documentElement.classList.contains('dark');
            const width = constellationSvg.clientWidth;
            const height = constellationSvg.clientHeight;
            const center = { x: width / 2, y: height / 2 };
            const radius = Math.min(width, height) * 0.4;
            
            // 绘制坐标轴
            const axisColor = isDarkMode ? "#6b7280" : "#9ca3af";
            const textColor = isDarkMode ? "#e5e7eb" : "#1f2937";
            
            // 创建X轴
            const xAxis = document.createElementNS(svgNS, "line");
            xAxis.setAttribute("x1", "0");
            xAxis.setAttribute("y1", center.y);
            xAxis.setAttribute("x2", width);
            xAxis.setAttribute("y2", center.y);
            xAxis.setAttribute("stroke", axisColor);
            xAxis.setAttribute("stroke-width", "1");
            constellationSvg.appendChild(xAxis);
            
            // 创建Y轴
            const yAxis = document.createElementNS(svgNS, "line");
            yAxis.setAttribute("x1", center.x);
            yAxis.setAttribute("y1", "0");
            yAxis.setAttribute("x2", center.x);
            yAxis.setAttribute("y2", height);
            yAxis.setAttribute("stroke", axisColor);
            yAxis.setAttribute("stroke-width", "1");
            constellationSvg.appendChild(yAxis);
            
            // 添加轴标签
            const xLabel = document.createElementNS(svgNS, "text");
            xLabel.setAttribute("x", width - 20);
            xLabel.setAttribute("y", center.y - 10);
            xLabel.setAttribute("fill", textColor);
            xLabel.setAttribute("font-size", "14");
            xLabel.textContent = "I";
            constellationSvg.appendChild(xLabel);
            
            const yLabel = document.createElementNS(svgNS, "text");
            yLabel.setAttribute("x", center.x + 10);
            yLabel.setAttribute("y", 20);
            yLabel.setAttribute("fill", textColor);
            yLabel.setAttribute("font-size", "14");
            yLabel.textContent = "Q";
            constellationSvg.appendChild(yLabel);
            
            // 绘制QPSK星座点
            const points = [
                { i: 1, q: 1, bits: "11", phase: "45°" },
                { i: -1, q: 1, bits: "01", phase: "135°" },
                { i: -1, q: -1, bits: "00", phase: "225°" },
                { i: 1, q: -1, bits: "10", phase: "315°" }
            ];
            
            const colors = ["#3b82f6", "#10b981", "#ef4444", "#f59e0b"];
            
            points.forEach((point, index) => {
                const x = center.x + point.i * radius;
                const y = center.y - point.q * radius;
                
                // 创建星座点
                const circle = document.createElementNS(svgNS, "circle");
                circle.setAttribute("cx", x);
                circle.setAttribute("cy", y);
                circle.setAttribute("r", "6");
                circle.setAttribute("fill", colors[index]);
                circle.classList.add("qpsk-constellation-point");
                constellationSvg.appendChild(circle);
                
                // 添加信息气泡（初始隐藏）
                const infoG = document.createElementNS(svgNS, "g");
                infoG.setAttribute("opacity", "0");
                
                // 背景矩形
                const bgRect = document.createElementNS(svgNS, "rect");
                const padding = 8;
                const rectWidth = 80;
                const rectHeight = 50;
                bgRect.setAttribute("x", x - rectWidth/2);
                bgRect.setAttribute("y", y - rectHeight - 15);
                bgRect.setAttribute("width", rectWidth);
                bgRect.setAttribute("height", rectHeight);
                bgRect.setAttribute("rx", "4");
                bgRect.setAttribute("fill", isDarkMode ? "#374151" : "#f3f4f6");
                bgRect.setAttribute("stroke", colors[index]);
                bgRect.setAttribute("stroke-width", "2");
                
                // 信息文本
                const bitsText = document.createElementNS(svgNS, "text");
                bitsText.setAttribute("x", x);
                bitsText.setAttribute("y", y - rectHeight + 15);
                bitsText.setAttribute("text-anchor", "middle");
                bitsText.setAttribute("fill", textColor);
                bitsText.setAttribute("font-size", "13");
                bitsText.textContent = `比特: ${point.bits}`;
                
                const phaseText = document.createElementNS(svgNS, "text");
                phaseText.setAttribute("x", x);
                phaseText.setAttribute("y", y - rectHeight + 35);
                phaseText.setAttribute("text-anchor", "middle");
                phaseText.setAttribute("fill", textColor);
                phaseText.setAttribute("font-size", "13");
                phaseText.textContent = `相位: ${point.phase}`;
                
                infoG.appendChild(bgRect);
                infoG.appendChild(bitsText);
                infoG.appendChild(phaseText);
                constellationSvg.appendChild(infoG);
                
                // 添加交互
                circle.addEventListener("mouseover", () => {
                    infoG.setAttribute("opacity", "1");
                });
                
                circle.addEventListener("mouseout", () => {
                    infoG.setAttribute("opacity", "0");
                });
            });
        }
        
        // 绘制QPSK发射端框图
        function drawTransmitterDiagram() {
            const canvas = document.getElementById('qpsk-transmitter-diagram');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth * 2;
            canvas.height = canvas.clientHeight * 2;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);
            
            const isDarkMode = document.documentElement.classList.contains('dark');
            const textColor = isDarkMode ? "#e5e7eb" : "#1f2937";
            const boxColor = isDarkMode ? "#4b5563" : "#e5e7eb";
            const lineColor = isDarkMode ? "#9ca3af" : "#6b7280";
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            ctx.clearRect(0, 0, width, height);
            ctx.font = "12px 'Noto Sans SC'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // 绘制框图组件
            function drawBlock(x, y, w, h, text, color = boxColor) {
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = textColor;
                ctx.fillText(text, x + w/2, y + h/2);
            }
            
            function drawLine(x1, y1, x2, y2, hasArrow = true) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = lineColor;
                ctx.stroke();
                
                // 绘制箭头
                if (hasArrow) {
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const length = 8;
                    ctx.beginPath();
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(x2 - length * Math.cos(angle - Math.PI/6), 
                              y2 - length * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(x2 - length * Math.cos(angle + Math.PI/6), 
                              y2 - length * Math.sin(angle + Math.PI/6));
                    ctx.closePath();
                    ctx.fillStyle = lineColor;
                    ctx.fill();
                }
            }
            
            // 框图布局
            const blockHeight = 30;
            const blockWidth = 80;
            const margin = 20;
            const centerY = height / 2;
            
            // 输入数据
            drawBlock(margin, centerY - 60, blockWidth, blockHeight, "输入比特流");
            
            // 串并转换
            drawBlock(margin + blockWidth + 30, centerY - 60, blockWidth, blockHeight, "串并转换");
            drawLine(margin + blockWidth, centerY - 45, margin + blockWidth + 30, centerY - 45);
            
            // I路和Q路
            const iqStartX = margin + blockWidth * 2 + 50;
            const qpathY = centerY + 20;
            const ipathY = centerY - 70;
            
            // I路分支
            drawLine(margin + blockWidth * 2 + 30, centerY - 45, iqStartX, centerY - 45);
            drawLine(iqStartX, centerY - 45, iqStartX, ipathY);
            drawBlock(iqStartX + 20, ipathY - blockHeight/2, blockWidth, blockHeight, "I路映射");
            
            // Q路分支
            drawLine(iqStartX, centerY - 45, iqStartX, qpathY);
            drawBlock(iqStartX + 20, qpathY - blockHeight/2, blockWidth, blockHeight, "Q路映射");
            
            // 载波生成
            const carrierX = iqStartX + blockWidth + 40;
            drawBlock(carrierX, centerY - 25, blockWidth, blockHeight, "载波生成");
            
            // 载波90度移相
            drawLine(carrierX + blockWidth/2, centerY - 25, carrierX + blockWidth/2, ipathY);
            drawLine(carrierX + blockWidth/2, centerY + 5, carrierX + blockWidth/2, qpathY);
            
            // I路调制
            const modStartX = iqStartX + blockWidth + 40;
            drawLine(iqStartX + blockWidth + 20, ipathY, modStartX + 40, ipathY);
            drawBlock(modStartX + 40, ipathY - blockHeight/2, blockWidth, blockHeight, "I路调制");
            drawBlock(modStartX + 40, qpathY - blockHeight/2, blockWidth, blockHeight, "Q路调制");
            
            // 混合器
            const mixerX = modStartX + blockWidth + 60;
            const mixerY = centerY - 25;
            drawBlock(mixerX, mixerY, blockWidth, blockHeight, "加法器");
            
            // 连接线
            drawLine(modStartX + blockWidth + 40, ipathY, mixerX, mixerY + blockHeight/2);
            drawLine(modStartX + blockWidth + 40, qpathY, mixerX, mixerY + blockHeight/2);
            
            // 输出
            drawLine(mixerX + blockWidth, mixerY + blockHeight/2, width - margin, mixerY + blockHeight/2);
            drawBlock(width - margin - blockWidth, mixerY, blockWidth, blockHeight, "QPSK信号");
            
            drawLine(carrierX + blockWidth/2, centerY - 25, carrierX + blockWidth/2 + 20, ipathY);
            drawLine(carrierX + blockWidth/2, centerY + 5, carrierX + blockWidth/2 + 20, qpathY, false);
            
            // 标记90°
            ctx.font = "10px 'Noto Sans SC'";
            ctx.fillStyle = textColor;
            ctx.fillText("0°", carrierX + blockWidth/2 + 20, ipathY - 15);
            ctx.fillText("90°", carrierX + blockWidth/2 + 20, qpathY + 15);
        }
        
        // 绘制QPSK接收端框图
        function drawReceiverDiagram() {
            const canvas = document.getElementById('qpsk-receiver-diagram');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.clientWidth * 2;
            canvas.height = canvas.clientHeight * 2;
            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvas.clientWidth * dpr;
            canvas.height = canvas.clientHeight * dpr;
            ctx.scale(dpr, dpr);
            
            const isDarkMode = document.documentElement.classList.contains('dark');
            const textColor = isDarkMode ? "#e5e7eb" : "#1f2937";
            const boxColor = isDarkMode ? "#4b5563" : "#e5e7eb";
            const lineColor = isDarkMode ? "#9ca3af" : "#6b7280";
            const width = canvas.clientWidth;
            const height = canvas.clientHeight;
            
            ctx.clearRect(0, 0, width, height);
            ctx.font = "12px 'Noto Sans SC'";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            // 绘制框图组件
            function drawBlock(x, y, w, h, text, color = boxColor) {
                ctx.fillStyle = color;
                ctx.strokeStyle = lineColor;
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.rect(x, y, w, h);
                ctx.fill();
                ctx.stroke();
                ctx.fillStyle = textColor;
                ctx.fillText(text, x + w/2, y + h/2);
            }
            
            function drawLine(x1, y1, x2, y2, hasArrow = true) {
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.strokeStyle = lineColor;
                ctx.stroke();
                
                // 绘制箭头
                if (hasArrow) {
                    const angle = Math.atan2(y2 - y1, x2 - x1);
                    const length = 8;
                    ctx.beginPath();
                    ctx.moveTo(x2, y2);
                    ctx.lineTo(x2 - length * Math.cos(angle - Math.PI/6), 
                              y2 - length * Math.sin(angle - Math.PI/6));
                    ctx.lineTo(x2 - length * Math.cos(angle + Math.PI/6), 
                              y2 - length * Math.sin(angle + Math.PI/6));
                    ctx.closePath();
                    ctx.fillStyle = lineColor;
                    ctx.fill();
                }
            }
            
            // 框图布局
            const blockHeight = 30;
            const blockWidth = 80;
            const margin = 20;
            const centerY = height / 2;
            
            // 接收信号
            drawBlock(margin, centerY - 15, blockWidth, blockHeight, "接收QPSK信号");
            
            // 本地载波
            const carrierX = margin + blockWidth + 30;
            const carrierY = centerY + 40;
            drawBlock(carrierX, carrierY, blockWidth, blockHeight, "本地载波");
            
            // 载波分支
            const iqStartX = carrierX + blockWidth/2;
            const qpathY = centerY + 20;
            const ipathY = centerY - 50;
            
            // 分支线
            drawLine(iqStartX, carrierY, iqStartX, ipathY);
            drawLine(iqStartX, carrierY, iqStartX, qpathY, false);
            
            // I路解调
            const demodStartX = margin + blockWidth + 60;
            drawBlock(demodStartX, ipathY - blockHeight/2, blockWidth, blockHeight, "I路解调");
            drawBlock(demodStartX, qpathY - blockHeight/2, blockWidth, blockHeight, "Q路解调");
            
            // 输入信号分支
            drawLine(margin + blockWidth, centerY, demodStartX, centerY, false);
            drawLine(margin + blockWidth + 30, centerY, margin + blockWidth + 30, ipathY);
            drawLine(margin + blockWidth + 30, centerY, margin + blockWidth + 30, qpathY);
            
            // 判决器
            const decisionX = demodStartX + blockWidth + 30;
            drawBlock(decisionX, ipathY - blockHeight/2, blockWidth, blockHeight, "I路判决");
            drawBlock(decisionX, qpathY - blockHeight/2, blockWidth, blockHeight, "Q路判决");
            
            drawLine(demodStartX + blockWidth, ipathY, decisionX, ipathY);
            drawLine(demodStartX + blockWidth, qpathY, decisionX, qpathY);
            
            // 并串转换
            const combinedX = decisionX + blockWidth + 30;
            const combinedY = centerY - 15;
            
            drawLine(decisionX + blockWidth, ipathY, combinedX, ipathY);
            drawLine(decisionX + blockWidth, qpathY, combinedX, qpathY);
            
            drawLine(combinedX, ipathY, combinedX, centerY);
            drawLine(combinedX, qpathY, combinedX, centerY);
            
            drawBlock(combinedX + 20, centerY - 15, blockWidth, blockHeight, "并串转换");
            
            // 输出
            drawLine(combinedX + blockWidth + 20, centerY, width - margin, centerY);
            drawBlock(width - margin - blockWidth, centerY - 15, blockWidth, blockHeight, "输出比特流");
            
            // 标记90°
            ctx.font = "10px 'Noto Sans SC'";
            ctx.fillStyle = textColor;
            ctx.fillText("0°", iqStartX + 20, ipathY - 15);
            ctx.fillText("90°", iqStartX + 20, qpathY + 15);
        }
        
        // QPSK仿真
        class QPSKSimulation {
            constructor() {
                this.bitSequence = "1010110001";
                this.samplesPerSymbol = 16;
                this.snrDb = 10;
                this.running = false;
                
                this.waveformChart = null;
                this.iqDataChart = null;
                this.modulatedSignalChart = null;
                this.constellationPlot = null;
                this.eyeDiagramI = null;
                this.eyeDiagramQ = null;
                
                this.setupEventListeners();
            }
            
            setupEventListeners() {
                const startButton = document.getElementById('start-simulation');
                const bitSequenceInput = document.getElementById('bit-sequence');
                const samplesPerSymbolInput = document.getElementById('samples-per-symbol');
                const snrInput = document.getElementById('snr-value');
                
                startButton.addEventListener('click', () => {
                    this.bitSequence = bitSequenceInput.value.replace(/[^01]/g, '');
                    if (this.bitSequence.length === 0) {
                        this.bitSequence = "1010110001";
                        bitSequenceInput.value = this.bitSequence;
                    }
                    
                    this.samplesPerSymbol = parseInt(samplesPerSymbolInput.value);
                    this.snrDb = parseInt(snrInput.value);
                    
                    this.startSimulation();
                });
            }
            
            startSimulation() {
                // 确保比特数是偶数
                if (this.bitSequence.length % 2 !== 0) {
                    this.bitSequence += "0";
                }
                
                const bits = this.bitSequence.split('').map(bit => parseInt(bit));
                const symbols = this.bitsToSymbols(bits);
                const upsampled = this.upsample(symbols, this.samplesPerSymbol);
                const filtered = this.pulseShapeFilter(upsampled, this.samplesPerSymbol);
                
                // 生成时间轴
                const time = Array.from({length: filtered.length}, (_, i) => i / this.samplesPerSymbol);
                
                // 生成载波
                const carrierI = time.map(t => Math.cos(2 * Math.PI * 4 * t));
                const carrierQ = time.map(t => Math.sin(2 * Math.PI * 4 * t));
                
                // 调制
                const modulated = filtered.map((symbol, i) => {
                    return symbol.real * carrierI[i] - symbol.imag * carrierQ[i];
                });
                
                // 添加噪声
                const noisySignal = this.addNoise(modulated, this.snrDb);
                
                // 解调
                const demodulated = this.demodulate(noisySignal, time, this.samplesPerSymbol);
                
                // 下采样和判决
                const detected = this.detectSymbols(demodulated, this.samplesPerSymbol);
                const detectedBits = this.symbolsToBits(detected);
                
                // 计算误码率
                const errors = bits.filter((bit, i) => bit !== detectedBits[i]).length;
                const ber = errors / bits.length;
                document.getElementById('ber-value').textContent = (ber * 100).toFixed(2) + '%';
                
                // 更新仿真图表
                this.updateWaveformChart(time, filtered, modulated, noisySignal);
                this.updateIQDataChart(time.slice(0, bits.length * this.samplesPerSymbol / 2), upsampled);
                this.updateModulatedSignalChart(time, modulated, noisySignal);
                this.updateConstellationPlot(demodulated, symbols);
                this.updateEyeDiagrams(demodulated, this.samplesPerSymbol);
            }
            
            bitsToSymbols(bits) {
                const symbols = [];
                for (let i = 0; i < bits.length; i += 2) {
                    const bit1 = bits[i];
                    const bit2 = i + 1 < bits.length ? bits[i + 1] : 0;
                    
                    if (bit1 === 0 && bit2 === 0) {
                        symbols.push({real: -1, imag: -1}); // 225°
                    } else if (bit1 === 0 && bit2 === 1) {
                        symbols.push({real: -1, imag: 1});  // 135°
                    } else if (bit1 === 1 && bit2 === 0) {
                        symbols.push({real: 1, imag: -1});  // 315°
                    } else {
                        symbols.push({real: 1, imag: 1});   // 45°
                    }
                }
                return symbols;
            }
            
            symbolsToBits(symbols) {
                const bits = [];
                for (const symbol of symbols) {
                    if (symbol.real < 0 && symbol.imag < 0) {
                        bits.push(0, 0); // 225°
                    } else if (symbol.real < 0 && symbol.imag > 0) {
                        bits.push(0, 1); // 135°
                    } else if (symbol.real > 0 && symbol.imag < 0) {
                        bits.push(1, 0); // 315°
                    } else {
                        bits.push(1, 1); // 45°
                    }
                }
                return bits;
            }
            
            upsample(symbols, samplesPerSymbol) {
                const result = [];
                for (const symbol of symbols) {
                    result.push(symbol);
                    for (let i = 1; i < samplesPerSymbol; i++) {
                        result.push({real: 0, imag: 0});
                    }
                }
                return result;
            }
            
            pulseShapeFilter(symbols, samplesPerSymbol) {
                // 简化的脉冲成型过滤器（矩形脉冲）
                const result = [];
                for (let i = 0; i < symbols.length; i += samplesPerSymbol) {
                    const symbol = symbols[i];
                    for (let j = 0; j < samplesPerSymbol; j++) {
                        result.push(symbol);
                    }
                }
                return result;
            }
            
            addNoise(signal, snrDb) {
                const snr = Math.pow(10, snrDb / 10);
                const signalPower = signal.reduce((sum, val) => sum + val * val, 0) / signal.length;
                const noisePower = signalPower / snr;
                const noiseStdDev = Math.sqrt(noisePower);
                
                return signal.map(sample => {
                    const noise = noiseStdDev * (Math.random() * 2 - 1);
                    return sample + noise;
                });
            }
            
            demodulate(signal, time, samplesPerSymbol) {
                const demodulated = [];
                const carrierI = time.map(t => Math.cos(2 * Math.PI * 4 * t));
                const carrierQ = time.map(t => -Math.sin(2 * Math.PI * 4 * t));
                
                for (let i = 0; i < signal.length; i++) {
                    const i_component = signal[i] * carrierI[i];
                    const q_component = signal[i] * carrierQ[i];
                    demodulated.push({real: i_component, imag: q_component});
                }
                
                return demodulated;
            }
            
            detectSymbols(demodulated, samplesPerSymbol) {
                const detected = [];
                for (let i = 0; i < demodulated.length; i += samplesPerSymbol) {
                    let sumReal = 0;
                    let sumImag = 0;
                    for (let j = 0; j < samplesPerSymbol; j++) {
                        if (i + j < demodulated.length) {
                            sumReal += demodulated[i + j].real;
                            sumImag += demodulated[i + j].imag;
                        }
                    }
                    
                    const avgReal = sumReal / samplesPerSymbol;
                    const avgImag = sumImag / samplesPerSymbol;
                    
                    detected.push({
                        real: avgReal > 0 ? 1 : -1,
                        imag: avgImag > 0 ? 1 : -1
                    });
                }
                return detected;
            }
            
            updateWaveformChart(time, filtered, modulated, noisySignal) {
                const ctx = document.getElementById('qpsk-waveform').getContext('2d');
                
                if (this.waveformChart) {
                    this.waveformChart.destroy();
                }
                
                // 只显示前几个符号以便观察
                const cutoff = Math.min(time.length, this.samplesPerSymbol * 8);
                const timeSlice = time.slice(0, cutoff);
                const filteredRealSlice = filtered.slice(0, cutoff).map(s => s.real);
                const filteredImagSlice = filtered.slice(0, cutoff).map(s => s.imag);
                const modulatedSlice = modulated.slice(0, cutoff);
                const noisySlice = noisySignal.slice(0, cutoff);
                
                this.waveformChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timeSlice.map(t => t.toFixed(1)),
                        datasets: [
                            {
                                label: 'I路基带信号',
                                data: filteredRealSlice,
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1
                            },
                            {
                                label: 'Q路基带信号',
                                data: filteredImagSlice,
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 2,
                                pointRadius: 0,
                                tension: 0.1
                            },
                            {
                                label: 'QPSK调制信号',
                                data: modulatedSlice,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                borderWidth: 1,
                                pointRadius: 0,
                                borderDash: [5, 5]
                            },
                            {
                                label: '噪声信号',
                                data: noisySlice,
                                borderColor: 'rgba(153, 102, 255, 0.5)',
                                borderWidth: 1,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: '符号时间'
                                }
                            },
                            y: {
                                min: -2.5,
                                max: 2.5
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }
            
            updateIQDataChart(time, symbols) {
                const ctx = document.getElementById('iq-data').getContext('2d');
                
                if (this.iqDataChart) {
                    this.iqDataChart.destroy();
                }
                
                const iData = symbols.map(s => s.real);
                const qData = symbols.map(s => s.imag);
                
                this.iqDataChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: time.map(t => t.toFixed(1)),
                        datasets: [
                            {
                                label: 'I数据',
                                data: iData,
                                borderColor: 'rgba(54, 162, 235, 1)',
                                borderWidth: 1,
                                pointRadius: 0,
                                stepped: true
                            },
                            {
                                label: 'Q数据',
                                data: qData,
                                borderColor: 'rgba(255, 99, 132, 1)',
                                borderWidth: 1,
                                pointRadius: 0,
                                stepped: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                min: -1.5,
                                max: 1.5
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                            }
                        }
                    }
                });
            }
            
            updateModulatedSignalChart(time, modulated, noisySignal) {
                const ctx = document.getElementById('modulated-signal').getContext('2d');
                
                if (this.modulatedSignalChart) {
                    this.modulatedSignalChart.destroy();
                }
                
                // 只显示前几个符号
                const cutoff = Math.min(time.length, this.samplesPerSymbol * 4);
                const timeSlice = time.slice(0, cutoff);
                const modulatedSlice = modulated.slice(0, cutoff);
                const noisySlice = noisySignal.slice(0, cutoff);
                
                this.modulatedSignalChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: timeSlice,
                        datasets: [
                            {
                                label: '无噪声信号',
                                data: modulatedSlice,
                                borderColor: 'rgba(75, 192, 192, 1)',
                                borderWidth: 2,
                                pointRadius: 0
                            },
                            {
                                label: '含噪声信号',
                                data: noisySlice,
                                borderColor: 'rgba(153, 102, 255, 0.7)',
                                borderWidth: 1,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                display: false
                            },
                            y: {
                                min: -3,
                                max: 3
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            }
                        }
                    }
                });
            }
            
            updateConstellationPlot(demodulated, originalSymbols) {
                const ctx = document.getElementById('qpsk-constellation-plot').getContext('2d');
                
                if (this.constellationPlot) {
                    this.constellationPlot.destroy();
                }
                
                // 下采样解调后的数据点，每个符号取中间点
                const sampledPoints = [];
                for (let i = 0; i < demodulated.length; i += this.samplesPerSymbol) {
                    if (i + Math.floor(this.samplesPerSymbol / 2) < demodulated.length) {
                        sampledPoints.push(demodulated[i + Math.floor(this.samplesPerSymbol / 2)]);
                    }
                }
                
                // 理论星座点
                const idealPoints = [
                    {real: 1, imag: 1},
                    {real: -1, imag: 1},
                    {real: -1, imag: -1},
                    {real: 1, imag: -1}
                ];
                
                this.constellationPlot = new Chart(ctx, {
                    type: 'scatter',
                    data: {
                        datasets: [
                            {
                                label: '接收符号',
                                data: sampledPoints.map(p => ({
                                    x: p.real,
                                    y: p.imag
                                })),
                                backgroundColor: 'rgba(153, 102, 255, 0.6)',
                                pointRadius: 4
                            },
                            {
                                label: '理想符号',
                                data: idealPoints.map(p => ({
                                    x: p.real,
                                    y: p.imag
                                })),
                                backgroundColor: 'rgba(255, 99, 132, 1)',
                                pointRadius: 8,
                                pointStyle: 'triangle'
                            },
                            {
                                label: '判决边界',
                                data: [],
                                showLine: true,
                                fill: false,
                                borderColor: 'rgba(0, 0, 0, 0.2)',
                                borderWidth: 1,
                                pointRadius: 0
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: {
                                min: -2,
                                max: 2,
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)',
                                    zeroLineColor: 'rgba(0, 0, 0, 0.3)'
                                }
                            },
                            y: {
                                min: -2,
                                max: 2,
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)',
                                    zeroLineColor: 'rgba(0, 0, 0, 0.3)'
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                position: 'top',
                            },
                            annotation: {
                                annotations: [
                                    {
                                        type: 'line',
                                        mode: 'horizontal',
                                        scaleID: 'y',
                                        value: 0,
                                        borderColor: 'rgba(0, 0, 0, 0.3)',
                                        borderWidth: 1
                                    },
                                    {
                                        type: 'line',
                                        mode: 'vertical',
                                        scaleID: 'x',
                                        value: 0,
                                        borderColor: 'rgba(0, 0, 0, 0.3)',
                                        borderWidth: 1
                                    }
                                ]
                            }
                        }
                    }
                });
            }
            
            updateEyeDiagrams(demodulated, samplesPerSymbol) {
                const ctxI = document.getElementById('eye-diagram-i').getContext('2d');
                const ctxQ = document.getElementById('eye-diagram-q').getContext('2d');
                
                if (this.eyeDiagramI) {
                    this.eyeDiagramI.destroy();
                }
                if (this.eyeDiagramQ) {
                    this.eyeDiagramQ.destroy();
                }
                
                // 生成眼图数据 - 重叠多个符号周期
                const eyeTracesI = [];
                const eyeTracesQ = [];
                const symPerTrace = 2; // 每个轨迹包含的符号数
                const traceLength = symPerTrace * samplesPerSymbol;
                
                for (let i = 0; i < demodulated.length - traceLength; i += samplesPerSymbol) {
                    const traceI = [];
                    const traceQ = [];
                    
                    for (let j = 0; j < traceLength; j++) {
                        if (i + j < demodulated.length) {
                            traceI.push(demodulated[i + j].real);
                            traceQ.push(demodulated[i + j].imag);
                        }
                    }
                    
                    eyeTracesI.push(traceI);
                    eyeTracesQ.push(traceQ);
                    
                    // 限制轨迹数量，避免图表过度复杂
                    if (eyeTracesI.length >= 10) break;
                }
                
                // X轴标签
                const xLabels = Array.from({length: traceLength}, (_, i) => i);
                
                // 生成数据集
                const datasetsI = eyeTracesI.map((trace, i) => ({
                    data: trace,
                    borderColor: `rgba(54, 162, 235, ${0.5 + 0.5 * (i / eyeTracesI.length)})`,
                    pointRadius: 0,
                    borderWidth: 1
                }));
                
                const datasetsQ = eyeTracesQ.map((trace, i) => ({
                    data: trace,
                    borderColor: `rgba(255, 99, 132, ${0.5 + 0.5 * (i / eyeTracesQ.length)})`,
                    pointRadius: 0,
                    borderWidth: 1
                }));
                
                // 创建眼图
                this.eyeDiagramI = new Chart(ctxI, {
                    type: 'line',
                    data: {
                        labels: xLabels,
                        datasets: datasetsI
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                min: -2,
                                max: 2
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
                
                this.eyeDiagramQ = new Chart(ctxQ, {
                    type: 'line',
                    data: {
                        labels: xLabels,
                        datasets: datasetsQ
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                min: -2,
                                max: 2
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            }
                        }
                    }
                });
            }
        }
        
        // 页面加载完成后初始化
        window.addEventListener('load', function() {
            // 初始化星座图
            drawQpskConstellation();
            
            // 初始化系统框图
            drawTransmitterDiagram();
            drawReceiverDiagram();
            
            // 初始化仿真
            const qpskSim = new QPSKSimulation();
            qpskSim.startSimulation(); // 加载时自动运行一次仿真
            
            // 窗口大小变化时重绘
            window.addEventListener('resize', function() {
                drawQpskConstellation();
                drawTransmitterDiagram();
                drawReceiverDiagram();
            });
            
            // 深色模式变化时重绘
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    if (mutation.attributeName === 'class') {
                        drawQpskConstellation();
                        drawTransmitterDiagram();
                        drawReceiverDiagram();
                    }
                });
            });
            
            observer.observe(document.documentElement, {attributes: true});
            
            // 渲染公式
            renderMathInElement(document.getElementById('qpsk-formula'));
            renderMathInElement(document.getElementById('iq-formula'));
            renderMathInElement(document.getElementById('modulation-formula'));
            renderMathInElement(document.getElementById('i-demodulation-formula'));
            renderMathInElement(document.getElementById('q-demodulation-formula'));
            renderMathInElement(document.getElementById('ber-formula'));
        });
    </script>
</body>
</html>